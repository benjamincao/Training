## 1. 微服务介绍
### 1.1 构建整体应用（monolithic application）
![整体应用](https://attachments.tower.im/tower/48dfadc46e0d4ff88fb7a49e16e8c946?filename=431978090737.png)
商业逻辑是整个应用核心，包括各种模块：服务，领域对象，事件等。围绕核心的是与外界沟通的适配器。
尽管有一个模块化的架构，但是应用是作为一个整体（monolith）来打包和部署的。这种样式开发的应用是很普遍的，因为ide和各种工具都聚焦于开发这样的应用。这样的应用开发和部署都很简单，很多项目的早期阶段都采用这种模式。


### 1.2 整体应用陷阱
不幸的是，这种简单的方法有巨大的限制。成功的商业都会随着时间增长甚至会变得特别复杂巨大。如果应用变得巨大并且复杂，开发团队也会陷入困境。任何敏捷的尝试都会变得无所适从。主要问题在于系统变得复杂无比，任何单独的开发者都不可能完全了解。结果就是修复bug和添加新功能都变得困难无比。而且会形成恶性循环，因为所有的修改都基于无法理解的基础代码。
这样巨大复杂的应用的另一个问题是它成为持续部署的阻碍，因为你每次都需要将整个系统全部部署，并进行整个系统的测试。
如果某些模块遭遇性能瓶颈，整体应用的扩展性也很差。例如进行计算模块是CPU消耗很大的，而缓存是内存需求敏感的，他们部署在一台机器上，我们只能在选择上进行妥协。
整体应用的可靠性也会比较差，任何模块的一个bug，都可能导致整个系统崩溃。
整体应用使得应用新的框架或者语言变得很困难。

### 1.3 解决复杂度（tackling complexity）的微服务
为了解决整体应用的问题，提出了微服务架构模式，将应用分为一些小的相互访问的服务。
![微服务架构](https://attachments.tower.im/tower/93c96b10f71d483ca283a48b244ef3e3?filename=431992337817.png)
一个服务实现截然不同的功能或者特性，例如订单管理，用户管理等。每一个小的服务都是六边形架构（hexagonal architecture）的，都有自己的商业逻辑和适配器。某些微服务可能提供一些API，某些微服务可能实现一个web UI。运行时，某个微服务实例可能是一个VM或者一个Docker容器。
现在应用的每个功能性领域都通过它自己的微服务来实现。此外，整个服务被分为一系列简单的服务。
每个后台服务都提供一些API，并且使用其余服务提供的API。

![扩展盒子](https://attachments.tower.im/tower/68690fb8e30640d7b838b08278dd7fcd?filename=431978489626.png)
微服务架构主要负责扩展盒子模型的Y轴扩展。X轴扩展主要是指使用load Balancer来运行多个服务实例，而Z轴扩展主要是指数据分区，将不同的请求路由到某个特殊的服务器。
微服务架构模型显著的影响了应用和数据库的关系。每个微服务有自己的数据库范例，这跟全企业数据范式（enterprise-wide data schema）不同，并且可能导致一些数据重复。但是每个服务有自己的数据库是必不可少的，因为它确保了系统的松耦合。
![微服务和数据库](https://attachments.tower.im/tower/30317603c2154f74853ce34c3349172b?filename=431978528901.png)
表面上看来，微服务架构跟SOA很像，都包含了一系列的服务。然而微服务架构没有SOA架构的那些商业化的、打包的web服务规范，也没有一个企业服务总线（Enterprise Service Bus）。微服务架构使用更简单的、更轻量级的协议例如REST等。

### 1.4 微服务的优点
* 解决了复杂度的问题.
微服务架构模式将其他模式下的整体应用分解为一系列的服务.尽管功能的数量没有变化,但是被拆散为可管理的分支或者服务,每一个服务都有一个RPC或者消息驱动的API作为定义明确的边界.微服务架构强制实行了在整体应用上无法实现的一定水平的模块化.因此,单独的服务更容易部署也更易于理解和维护.
* 独立团队开发独立模块成为可能.
开发团队可以聚焦于自己开发的服务,可以选用自己喜欢的技术,只要接受API的约束.开发团队在开发新的服务时,不需要使用已经过时的技术,并且因为微服务的"微",可以随时使用新的技术来重构原有的服务.
* 部署的独立性
开发团队不需要相互协调来部署自己所作的更新,因为服务的隔离,只要新的服务被测试通过可以随时部署.微服务使得持续部署成为可能.
* 扩展的独立性
我们可以根据用量和可用性的要求随意部署某个服务的多个实例,另外,我们也可以根据微服务的类型选择最适合的硬件配置,比如CPU敏感的应用(计算)或者内存敏感的应用(缓存)等.

### 1.5 微服务的缺点
没有银弹(there are no silver bullets).
* 微服务的大小
微服务模式过分的强调了服务的大小(size),有一些开发者建议建立细粒度的10-100 LOC(line of code?)服务.尽管小的服务是可取的,但是一定要记住,这只是达到目的的一种手段而不是目的.微服务架构的目的是尽可能的分解引用,以便于应用的敏捷开发和部署.
* 分布式的复杂度
微服务是一个分布式系统,这带来了许多的复杂度.开发者需要选择并实现基于消息或者RPC的进程间通信机制.另外,开发者需要编写代码来处理局部失效(partial failure),因为某个请求的服务可能很慢或者不可用.相比于整体应用的模块通过语言级别(language-level)的方法或者子过程调用,这要复杂的多.
* 分区数据库架构(partitioned database architecture)
一次更新多个业务实体的商业交易时很常见的,在整体应用中这样的操作不需要花费太多精力,因为只有一个数据库,数据库本身提供了事务机制.在基于微服务的应用中,需要更新多个服务拥有的多个数据库.使用分布式的事务并不是一个好的选择,不仅因为CAP原理,今天使用的许多高可扩展性的NoSQL数据库和消息代理都不支持分布式事务.我们不得不使用一个最终一致性(an eventual consistency base approach)的方法,这对大部分的开发者来说都是一个挑战.
* 测试的复杂度
使用现代的web框架,启动一个整体的web应用并且执行一些单元测试是很容易的哦,但是在微服务中,可能需要启动服务本身以及它所依赖的所有服务.当然这并不是难事(that is not rocket science),但是也不要低估这样做的复杂性.
* 跨越多个服务的更新
建设我们需要实现一个用户故事(story),需要更改A B C,在整体应用中,我们只需要更改这些相应模块,整合更改,然后一次部署.但是在微服务架构中,我们需要仔细计划和协调每个服务的上线.例如我们需要先更新C,然后更新B,然后更新A.不过幸运的是,大部分的更新(change)通常只影响一个服务,需要协调的多个服务的更新时很少的.
* 部署的复杂性
整体应用基本上都是部署在复杂均衡器后的一系列的同样的服务器.每个应用实例都是配置为基础服务,例如数据库,消息代理等的地址.相反,微服务包含大量的服务,每个服务都有多个运行时实例,也有更多的需要配置,部署,扩展,管理的部件.另外也需要实现一个服务发现机制来让服务来发现它需要通信的服务的地址.传统的基于票据(ticket-based)的麻烦和手工操作的方法不能扩展到这样的复杂度.因此成功的部署微服务应用需要开发者对部署方法的更进一步的控制,以及高水平的自动化.

